<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>MDC Tone Watcher — simple 3s learn</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:16px}
  button{padding:10px 14px;margin:6px 8px 6px 0;font-size:15px}
  #log{white-space:pre-wrap;background:#111;color:#0f0;padding:10px;border-radius:6px;min-height:110px}
  label{display:inline-block;margin:6px 12px 6px 0}
</style>
</head>
<body>
  <h2>MDC Tone Watcher</h2>
  <p>Allow mic → Start Listening → <b>Record Tone Sample (learn)</b> while the full ~3s alert plays once. Keep this tab visible.</p>

  <div>
    <button id="start">Start Listening</button>
    <button id="stop" disabled>Stop</button>
    <button id="learn" title="Capture ~3 seconds of the alert tone">Record Tone Sample (learn)</button>
    <button id="test">Test Alert</button>
  </div>

  <label>Sensitivity
    <input id="sens" type="range" min="0.02" max="0.5" step="0.01" value="0.10">
  </label>

  <div id="log">Status: idle</div>

<script>
/*** === CONFIG: put your webhook URL here (IFTTT, Pushover endpoint via webhook relay, Telegram, etc.) === ***/
const WEBHOOK_URL = https://maker.ifttt.com/trigger/MDC_Call_Alert/with/key/cSJ4VM9aezFFbRFOgHGDv4; // e.g. https://maker.ifttt.com/trigger/mdc_call_alert/with/key/XXXX

/*** === Minimal code: same behavior as original + only 2 changes (3s learn + sustained match) === ***/
const logEl = document.getElementById('log'), sensEl = document.getElementById('sens');
const btnStart = document.getElementById('start'), btnStop = document.getElementById('stop');
const btnLearn = document.getElementById('learn'), btnTest = document.getElementById('test');

let ctx, analyser, mic, stream, listening=false, wakeLock=null;

// Learned pattern (average spectrum of ~3s capture)
let learnedAvg = null;

// Rolling similarity window for sustained detection
const FRAME_MS = 80;             // ~12.5 fps
const LEARN_MS = 3000;           // capture ~3 seconds
const WINDOW_MS = 2400;          // require ~2.4s sustained match
const MAX_WINDOW = Math.floor(WINDOW_MS / FRAME_MS);
const MIN_ENERGY = 0.10;         // gate: ignore quiet frames
let lastTick = 0;
let simWindow = [];
let cooldown = false;

function log(s){ logEl.textContent = new Date().toLocaleTimeString()+" — "+s+"\n"+logEl.textContent; }

function toLinear(db){ return Math.max(0,(db+140)/140); }
function normalize(arr){
  const out=new Float32Array(arr.length); let m=0;
  for(let i=0;i<arr.length;i++){ if(arr[i]>m) m=arr[i]; }
  if(m===0) m=1;
  for(let i=0;i<arr.length;i++) out[i]=arr[i]/m;
  return out;
}
function cosSim(a,b){
  let d=0,na=0,nb=0;
  for(let i=0;i<a.length;i++){ d+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; }
  return d/(Math.sqrt(na)*Math.sqrt(nb)+1e-9);
}
function avg(a){ if(!a.length) return 0; let s=0; for(const x of a) s+=x; return s/a.length; }

async function sendWebhook(){
  if(!WEBHOOK_URL){ log('No webhook set (local alert only).'); beep(); return; }
  try{
    await fetch(WEBHOOK_URL, {method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({value1:'MDC tone detected', t:new Date().toISOString()})});
    log('Webhook sent');
  } catch(e){ log('Webhook error: '+e.message); }
  beep();
}

function beep(){
  navigator.vibrate && navigator.vibrate([200,80,200,80,400]);
  const ac = new (window.AudioContext||window.webkitAudioContext)();
  const o = ac.createOscillator(), g = ac.createGain();
  o.connect(g); g.connect(ac.destination);
  o.type='sine'; o.frequency.value=880; g.gain.value=0.0001;
  o.start();
  g.gain.linearRampToValueAtTime(0.85, ac.currentTime+0.02);
  g.gain.linearRampToValueAtTime(0.0001, ac.currentTime+0.7);
  o.stop(ac.currentTime+0.72);
}

async function requestWakeLock(){
  try{ if('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); } }catch(e){ /* ignore */ }
}
async function releaseWakeLock(){ try{ if(wakeLock){ await wakeLock.release(); wakeLock=null; } }catch(e){} }

btnStart.onclick = async ()=>{
  if(listening) return;
  try{
    ctx = new (window.AudioContext||window.webkitAudioContext)();
    stream = await navigator.mediaDevices.getUserMedia({
      audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });
    mic = ctx.createMediaStreamSource(stream);
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.4;
    mic.connect(analyser);
    listening=true; btnStart.disabled=true; btnStop.disabled=false;
    log('Listening started');
    await requestWakeLock();
    loop();
  }catch(e){ log('Mic error: '+e.message); }
};

btnStop.onclick = async ()=>{
  listening=false; btnStart.disabled=false; btnStop.disabled=true;
  try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch(e){}
  try{ ctx && ctx.close(); }catch(e){}
  await releaseWakeLock();
  log('Stopped');
};

btnLearn.onclick = ()=>{
  if(!analyser){ log('Start listening first.'); return; }
  log('Learning ~3s… play ONE full alert now.');
  const frames = [];
  const start = performance.now();
  (function collect(){
    const f = new Float32Array(analyser.frequencyBinCount);
    analyser.getFloatFrequencyData(f);
    for(let i=0;i<f.length;i++) f[i] = toLinear(f[i]);
    frames.push( normalize(f) );
    if(performance.now() - start < LEARN_MS){
      setTimeout(collect, FRAME_MS);
    } else {
      // average spectrum over the 3s sample
      const avgSpec = new Float32Array(frames[0].length);
      for(let i=0;i<avgSpec.length;i++){
        let s=0; for(const fr of frames) s+=fr[i];
        avgSpec[i]=s/frames.length;
      }
      learnedAvg = normalize(avgSpec);
      log(`Tone learned (~${(frames.length*FRAME_MS/1000).toFixed(1)}s, ${frames.length} frames).`);
      // reset rolling window
      simWindow.length = 0;
    }
  })();
};

btnTest.onclick = ()=>{ log('Test fired'); sendWebhook(); };

function loop(){
  if(!listening) return;
  const now = performance.now();
  if(now - lastTick < FRAME_MS){ return requestAnimationFrame(loop); }
  lastTick = now;

  const buf = new Float32Array(analyser.frequencyBinCount);
  analyser.getFloatFrequencyData(buf);
  for(let i=0;i<buf.length;i++) buf[i] = toLinear(buf[i]);
  const spec = normalize(buf);

  // energy gate to ignore low-level noise
  let energy=0; for(let i=0;i<spec.length;i++) energy+=spec[i]; energy/=spec.length;
  if(energy < MIN_ENERGY){
    simWindow.push(0);
  } else if(learnedAvg){
    const sim = cosSim(spec, learnedAvg);
    simWindow.push(sim);
  } else {
    simWindow.push(0);
  }

  if(simWindow.length > MAX_WINDOW) simWindow.shift();

  // sustained threshold: base very strict, slider can loosen slightly
  const ease = parseFloat(sensEl.value);        // 0.02..0.5
  const threshold = 0.96 - (ease * 0.20);       // default ~0.96; loosest ~0.86
  const winAvg = avg(simWindow);

  if(!cooldown && learnedAvg && winAvg >= threshold){
    log(`MATCH sustained avg=${winAvg.toFixed(3)} (thr=${threshold.toFixed(3)})`);
    cooldown = true; listening = false;
    sendWebhook();
    setTimeout(()=>{ cooldown=false; listening=true; simWindow.length=0; log('Resumed'); }, 2500);
  }

  requestAnimationFrame(loop);
}
</script>
</body>
</html>

