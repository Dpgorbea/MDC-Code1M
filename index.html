<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>MDC Tone Watcher â€” 3s Learn + Sustained Match</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --bg:#0b0b0b; --fg:#e8e8e8; --mut:#9aa3a7; --ok:#31d158; --warn:#ffd44a; --bad:#ff6b6b; --card:#151515; }
  html,body { background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; margin:0; }
  .wrap { max-width:760px; margin:24px auto; padding:16px; }
  h1 { font-size:20px; margin:0 0 8px; }
  p, label, small { color:var(--mut); }
  .row { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0; }
  button, select, input[type="text"] {
    background:var(--card); color:var(--fg); border:1px solid #2a2a2a; border-radius:10px; padding:10px 14px; font-size:15px;
  }
  button { cursor:pointer; }
  button:disabled { opacity:.55; cursor:not-allowed; }
  .card { background:var(--card); border:1px solid #222; border-radius:12px; padding:12px; margin:12px 0; }
  #log { white-space:pre-wrap; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
         background:#0d0d0d; color:#8ff58b; border-radius:10px; padding:10px; min-height:120px; }
  .pill { display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #2a2a2a; background:#131313; }
  .ok { color:var(--ok); border-color:#1f5; }
  .warn { color:var(--warn); border-color:#fc4; }
  .bad { color:var(--bad); border-color:#f66; }
  .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  @media (max-width:640px){ .grid { grid-template-columns:1fr; } }
</style>
</head>
<body>
<div class="wrap">
  <h1>MDC Tone Watcher</h1>
  <p>Train it once with your patrol carâ€™s 3-second alert tone. It will only trigger when it hears a sustained match. Keep this tab visible; allow mic.</p>

  <!-- ===== CONFIGURE YOUR NOTIFICATION METHOD ===== -->
  <div class="card">
    <b>Notification Method</b>
    <p>Choose ONE method and fill the fields.</p>
    <div class="grid">
      <div>
        <label><input type="radio" name="method" value="IFTTT" checked> IFTTT Webhook</label>
        <input id="iftttUrl" type="text" placeholder="https://maker.ifttt.com/trigger/MDC_Call_Alert/with/key/cSJ4VM9aezFFbRFOgHGDv4" style="width:100%; margin-top:6px;">
      </div>
      <div>
        <label><input type="radio" name="method" value="PUSHOVER"> Pushover (fast, $4.99 one-time)</label>
        <input id="poToken" type="text" placeholder="Pushover API token" style="width:100%; margin-top:6px;">
        <input id="poUser"  type="text" placeholder="Pushover user key"  style="width:100%; margin-top:6px;">
      </div>
      <div>
        <label><input type="radio" name="method" value="TELEGRAM"> Telegram Bot (free)</label>
        <input id="tgToken" type="text" placeholder="Bot token (e.g. 1234:ABC...)" style="width:100%; margin-top:6px;">
        <input id="tgChat"  type="text" placeholder="Chat ID (your ID)" style="width:100%; margin-top:6px;">
      </div>
      <div>
        <label><input type="radio" name="method" value="NONE"> Local alert only (beep + vibrate)</label>
      </div>
    </div>
  </div>

  <!-- ===== CONTROLS ===== -->
  <div class="card">
    <div class="row">
      <button id="start">Start Listening</button>
      <button id="stop" disabled>Stop</button>
      <button id="learn" title="Capture ~3 seconds of the alert tone">Record Tone Sample (learn)</button>
      <button id="test">Test Alert</button>
    </div>
    <div class="row">
      <label>Sensitivity
        <input id="sens" type="range" min="0.02" max="0.5" step="0.01" value="0.12">
      </label>
      <label>Mic:
        <select id="micSelect"></select>
      </label>
      <span id="status" class="pill warn">idle</span>
    </div>
    <small>Tip: keep the phone/computer near the speaker that plays the CAD alert. Tab must stay visible. Screen wake-lock is automatic while listening.</small>
  </div>

  <!-- ===== LOG ===== -->
  <div class="card">
    <div id="log">Log ready.</div>
  </div>
</div>

<script>
/*** ---------- UTILITIES ---------- ***/
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const sensEl = document.getElementById('sens');
const micSelect = document.getElementById('micSelect');
const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');
const learnBtn = document.getElementById('learn');
const testBtn  = document.getElementById('test');

const iftttUrl = document.getElementById('iftttUrl');
const poToken  = document.getElementById('poToken');
const poUser   = document.getElementById('poUser');
const tgToken  = document.getElementById('tgToken');
const tgChat   = document.getElementById('tgChat');

const methodRadios = [...document.querySelectorAll('input[name="method"])];
const getMethod = ()=> methodRadios.find(r=>r.checked)?.value || 'IFTTT';

function log(s){
  const line = new Date().toLocaleTimeString() + " â€” " + s + "\n";
  logEl.textContent = line + logEl.textContent;
}
function setStatus(txt, cls='warn'){
  statusEl.textContent = txt;
  statusEl.className = 'pill ' + cls;
}

/*** ---------- AUDIO SETUP ---------- ***/
let ctx, analyser, micNode, stream, wakeLock=null;
let listening=false, cooldown=false;
let learnedFrames = null;      // array of spectra (~3s)
let frameWindow = [];          // rolling similarities
let lastLoopTs = 0;

// Detection parameters
const FRAME_MS   = 80;         // ~12.5 fps
const LEARN_MS   = 3000;       // learn ~3s
const WINDOW_MS  = 2400;       // require sustained match over last ~2.4s
const MAX_WINDOW = Math.floor(WINDOW_MS / FRAME_MS);
let   MIN_ENERGY = 0.08;       // ignore very quiet frames

function toLinear(db){ return Math.max(0,(db+140)/140); }
function normalize(arr){
  const out = new Float32Array(arr.length);
  let m = 0; for(let i=0;i<arr.length;i++) if(arr[i]>m) m=arr[i];
  if(m===0) m=1;
  for(let i=0;i<arr.length;i++) out[i] = arr[i]/m;
  return out;
}
function cosSim(a,b){
  let d=0,na=0,nb=0; for(let i=0;i<a.length;i++){ d+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; }
  return d / (Math.sqrt(na)*Math.sqrt(nb) + 1e-9);
}
function avg(arr){ if(!arr.length) return 0; let s=0; for(const x of arr) s+=x; return s/arr.length; }

async function requestWakeLock(){
  try{
    if('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); log('WakeLock ON'); }
  }catch(e){ log('WakeLock err: '+e.message); }
}
async function releaseWakeLock(){ try{ if(wakeLock){ await wakeLock.release(); wakeLock=null; log('WakeLock OFF'); } }catch(e){} }

function localAlert(){
  navigator.vibrate && navigator.vibrate([240,80,240,80,500]);
  const ac = new (window.AudioContext||window.webkitAudioContext)();
  const o  = ac.createOscillator();
  const g  = ac.createGain();
  o.connect(g); g.connect(ac.destination);
  o.type='sine'; o.frequency.value=880;
  g.gain.value=0.0001; o.start();
  g.gain.linearRampToValueAtTime(0.85, ac.currentTime+0.02);
  g.gain.linearRampToValueAtTime(0.0001, ac.currentTime+0.7);
  o.stop(ac.currentTime+0.72);
}

/*** ---------- WEBHOOKS ---------- ***/
async function sendNotification(){
  const method = getMethod();
  try{
    if(method==='IFTTT'){
      const url = (iftttUrl.value||'').trim();
      if(!url){ log('IFTTT URL empty (skipping remote push).'); localAlert(); return; }
      await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ value1:'MDC tone detected', t:new Date().toISOString() })});
      log('IFTTT webhook sent.');
    } else if(method==='PUSHOVER'){
      const token = poToken.value.trim(), user = poUser.value.trim();
      if(!token || !user){ log('Pushover token/user empty.'); localAlert(); return; }
      await fetch('https://api.pushover.net/1/messages.json', {method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ token, user, message:'ðŸš” New call assigned â€” check MDC' })});
      log('Pushover sent.');
    } else if(method==='TELEGRAM'){
      const token = tgToken.value.trim(), chat = tgChat.value.trim();
      if(!token || !chat){ log('Telegram token/chat empty.'); localAlert(); return; }
      const url = `https://api.telegram.org/bot${encodeURIComponent(token)}/sendMessage`+
                  `?chat_id=${encodeURIComponent(chat)}&text=${encodeURIComponent('ðŸš” New call assigned â€” check MDC')}`;
      await fetch(url);
      log('Telegram sent.');
    } else {
      log('Local alert only.');
    }
  } catch(e){
    log('Notify error: '+e.message);
  }
  localAlert();
}

/*** ---------- DEVICE PICKER ---------- ***/
async function populateMics(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d=>d.kind==='audioinput');
    micSelect.innerHTML = '';
    for(const d of mics){
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `Mic ${micSelect.length+1}`;
      micSelect.appendChild(opt);
    }
  }catch(e){ log('enumerateDevices error: '+e.message); }
}

/*** ---------- LISTEN / LEARN / LOOP ---------- ***/
async function startListening(){
  if(listening) return;
  try{
    ctx = new (window.AudioContext||window.webkitAudioContext)();
    const constraints = { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } };
    if(micSelect.value){ constraints.audio.deviceId = { exact: micSelect.value }; }
    stream  = await navigator.mediaDevices.getUserMedia(constraints);
    micNode = ctx.createMediaStreamSource(stream);
    analyser = ctx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.4;
    micNode.connect(analyser);
    listening = true; startBtn.disabled=true; stopBtn.disabled=false;
    setStatus('listening', 'ok'); log('Listeningâ€¦');
    await requestWakeLock();
    detectLoop();
  }catch(e){
    log('Mic error: '+e.message);
    setStatus('mic error', 'bad');
  }
}
async function stopListening(){
  listening=false; startBtn.disabled=false; stopBtn.disabled=true;
  try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch(e){}
  try{ ctx && ctx.close(); }catch(e){}
  await releaseWakeLock();
  setStatus('stopped', 'warn'); log('Stopped.');
}

function learnTone(){
  if(!analyser){ log('Start listening first.'); return; }
  frameWindow.length = 0;
  learnedFrames = null;
  log('Learning ~3sâ€¦ play ONE full alert now.');
  const frames = [];
  const start  = performance.now();
  (function collect(){
    const fdb = new Float32Array(analyser.frequencyBinCount);
    analyser.getFloatFrequencyData(fdb);
    for(let i=0;i<fdb.length;i++) fdb[i] = toLinear(fdb[i]);
    frames.push( normalize(fdb) );
    if(performance.now() - start < LEARN_MS){
      setTimeout(collect, FRAME_MS);
    } else {
      learnedFrames = frames;
      // precompute average spectrum
      const avgSpec = new Float32Array(learnedFrames[0].length);
      for(let i=0;i<avgSpec.length;i++){ let s=0; for(const fr of learnedFrames) s+=fr[i]; avgSpec[i]=s/learnedFrames.length; }
      learnedFrames.avg = normalize(avgSpec);
      log(`Tone learned with ${frames.length} frames (~${(frames.length*FRAME_MS/1000).toFixed(1)}s).`);
    }
  })();
}

function detectLoop(){
  if(!listening) return;
  const now = performance.now();
  if(now - lastLoopTs < FRAME_MS){ return requestAnimationFrame(detectLoop); }
  lastLoopTs = now;

  const fdb = new Float32Array(analyser.frequencyBinCount);
  analyser.getFloatFrequencyData(fdb);
  for(let i=0;i<fdb.length;i++) fdb[i] = toLinear(fdb[i]);
  const spec = normalize(fdb);

  // Energy gate
  let energy = 0; for(let i=0;i<spec.length;i++) energy += spec[i]; energy /= spec.length;
  if(energy < MIN_ENERGY){
    frameWindow.push(0);
  } else if(learnedFrames && learnedFrames.avg){
    const sim = cosSim(spec, learnedFrames.avg);
    frameWindow.push(sim);
  } else {
    frameWindow.push(0);
  }
  if(frameWindow.length > MAX_WINDOW) frameWindow.shift();

  // Threshold (stricter by default; slider loosens slightly)
  const ease = parseFloat(sensEl.value);          // 0.02..0.5
  const threshold = 0.95 - (ease * 0.25);        // ~0.95 default, down to ~0.825 if fully loose
  const winAvg = avg(frameWindow);

  if(!cooldown && learnedFrames && winAvg >= threshold){
    log(`MATCH sustained avg=${winAvg.toFixed(3)} (thr=${threshold.toFixed(3)})`);
    setStatus('alert', 'bad');
    cooldown = true; listening = false;
    sendNotification();
    // cooldown then resume
    setTimeout(()=>{ cooldown=false; listening=true; frameWindow.length=0; setStatus('listening','ok'); log('Resumed.'); }, 2500);
  }

  requestAnimationFrame(detectLoop);
}

/*** ---------- EVENTS ---------- ***/
startBtn.onclick = startListening;
stopBtn.onclick  = stopListening;
learnBtn.onclick = learnTone;
testBtn.onclick  = ()=>{ log('Test fired.'); setStatus('test','ok'); sendNotification(); };

(async function init(){
  setStatus('idle','warn');
  // ask for temp mic to list devices (some browsers require a prior permission)
  try{
    await navigator.mediaDevices.getUserMedia({audio:true});
  }catch(e){ /* ignore here; user will be prompted on Start */ }
  await populateMics();
  log('Ready. Choose mic (if needed), press Start, then Record Tone Sample and play ONE full alert (~3s).');
})();
</script>
</body>
</html>
